# Техрезюме проекта «Калькулятор КБЖУ — лид‑магнит»

> Здесь буду собирать полное резюме и рекомендации по проекту по мере анализа файлов.

---

## 1) Краткое описание (после анализа run.py)

- **Назначение:** точка входа бота‑лид‑магнита (aiogram 3.x), управление жизненным циклом: логирование, инициализация БД, подключение роутеров (`user`, `admin`), проверка интеграции с n8n, запуск поллинга и корректное завершение.
- **Входная точка:** `asyncio.run(main())` → `main()`.
- **Интеграции:** SQLite/БД через `async_main()` (из `app.database.models`), n8n через `N8N_WEBHOOK_URL` (опциональный тест соединения в DEBUG), таймер‑сервис (`TimerService`) в `app.webhook`.
- **Конфигурация:** импорт из `config` (`TOKEN`, `DEBUG`, `N8N_WEBHOOK_URL`), парс‑мод по умолчанию: `HTML`.
- **Запуск:** поллинг (`dp.start_polling(bot)`), FSM‑память: `MemoryStorage()`.

## 2) Карта репозитория (будет дополняться)
- `run.py` — точка входа (анализ готов)
- `requirements.txt` — зависимость и версии (анализ ниже)
- ...

## 2.1) Зависимости (requirements.txt)
```
aiogram==3.22.0
sqlalchemy==2.0.30
aiosqlite==0.20.0
pydantic==2.7.3
aiofiles==23.2.1
aiohttp==3.9.5
python-dotenv==1.0.1
Flask==2.3.3
Flask-Limiter==3.12
```

### Что видно по стеку
- **Ядро бота:** `aiogram 3.x` + `aiohttp` (сетевой стек), FSM — в памяти (из run.py).
- **Данные:** `SQLAlchemy 2.0` + `aiosqlite` — асинхронный SQLite‑драйвер, подходит для лид‑магнита.
- **Валидация/модели:** `pydantic 2.x` — современный API, быстрый парсинг конфигурации/DTO.
- **Файлы:** `aiofiles` — вероятно для асинхронной работы с фото/доками.
- **Конфиг:** `python-dotenv` — подгрузка `.env` в рантайме.
- **HTTP‑вход:** `Flask` + `Flask-Limiter` — вероятно вспомогательный HTTP‑сервис (healthcheck, входящие вебхуки, приём событий). В `run.py` Flask не используется, значит HTTP‑часть живёт в другом модуле.

### Заметки и риски по версиям
- **Пин «жёсткими» версиями** обеспечивает воспроизводимость билдов в Docker (плюс). Минус — требуется периодический аудит обновлений (security/bugfix). Можно рассмотреть `constraints.txt` или периодический `pip-compile` (заметка без изменения подхода).
- **`aiogram 3.22.0`**: актуальная ветка 3.x. Проверьте совместимость с вашей версией Python в контейнере (3.12/3.13) — 3.x обычно совместим, но лучше иметь тесты запуска.
- **`aiohttp 3.9.5`**: корректно для aiogram 3.x. При обновлении aiohttp иногда меняется политика SSL/timeout — держать в уме.
- **`Flask 2.3.3`**: стабильная, совместима с Python ≥3.8, async‑views поддерживаются частично. Если Flask нужен только для healthcheck — это ок; если планируются нагруженные входящие вебхуки, возможно рассмотреть единый ASGI‑стек, но это опционально.
- **`Flask-Limiter 3.12`**: добавляет rate‑limit для входящих HTTP; важно для публичных эндпоинтов. Убедитесь, что лимиты считывают реальный IP за прокси (X‑Forwarded‑For) при деплое за Nginx/Traefik (заметка).
- **`pydantic 2.7.3`**: ок. Если в проекте используются плагины под v1 — проверить отсутствие смешения v1/v2 API.

### Потенциально лишние/«молчащие» зависимости
- Если Flask/Flask‑Limiter фактически не используются (в текущем релизе на поллинге без HTTP‑эндпоинтов), они оставляют след в образе. Это не критично, но отмечаю для периодического «гарденинга» зависимостей.

### Небольшие рекомендации (без правок кода)
- **Отчёт о зависимостях:** завести краткий CHANGELOG зависимостей (когда и зачем обновляли ключевые пакеты: aiogram, SQLAlchemy, aiohttp).
- **Security‑скан:** периодический `pip-audit`/`safety` на CI для фикса CVE.
- **Маркировка версии приложения:** добавить `APP_VERSION` в env и лог старта — помогает сверять «что именно задеплоено».

## 3) Анализ run.py (последовательно и детально)

### Импорты и конфигурация
- Используются: `aiogram` (Bot/Dispatcher/routers, FSM‑storage), `logging`, `asyncio`.
- Конфиг из `config`: `TOKEN`, `DEBUG`, `N8N_WEBHOOK_URL`. ✅ Чисто, без хардкода.
- Роутеры: `app.user.user` и `app.admin.admin` — явная модульность.

### Логирование и режимы
- Базовое логирование через `logging.basicConfig(level=...)` + `print()` для статусов.
- В `DEBUG` уровень INFO, в проде WARNING. Сообщения старта явно помечены `[DEBUG]/[PROD]`.
- Печать префиксов `[OK]/[WARN]/[ERROR]/[SUCCESS]` упрощает чтение docker‑логов.

**Наблюдение:** смешаны `logging` и `print`. Для единообразия и парсинга логов в будущем (ELK/CloudWatch) лучше было бы единообразно через `logging` (заметка, без правок).

### Инициализация бота/диспетчера
- `Bot(..., default=DefaultBotProperties(parse_mode=HTML))` — единый парс‑мод на все сообщения, удобно для форматирования.
- `Dispatcher(storage=MemoryStorage())` — FSM в памяти процесса. Для одного контейнера это ок; при горизонтальном масштабировании потребуется разделённое хранилище (Redis/БД) (заметка о масштабировании).
- Подключение роутеров: `dp.include_routers(user, admin)` — чистая раздельная ответственность.

### Регистрация хуков жизненного цикла
- `dp.startup.register(startup)` / `dp.shutdown.register(shutdown)` — правильно, хуки в одном месте.
- `startup()`:
  - `await async_main()` — инициализация/миграция БД при старте. ✅
  - Проверка `N8N_WEBHOOK_URL` с маскировкой: печатает только первые 50 символов (`[:50]...`) — безопаснее, чем полное значение.
  - В DEBUG — ленивый импорт и асинхронный тест вебхука `test_webhook_connection()`. Ошибки переводятся в предупреждение, не падают прод.
- `shutdown()`:
  - Остановка таймеров через `TimerService.cancel_timer(user_id)` для всех активных. Используется `list(keys)` — избегает ошибок при модификации словаря во время итерации. ✅

### Запуск и завершение
- `await dp.start_polling(bot)` — классический поллинг. Для Docker‑прода ок, если ресурсов/РПМ достаточно. Webhook‑режим не требуется.
- `finally: await bot.session.close()` — явное закрытие HTTP‑сессии.
- Глобальные перехваты: `KeyboardInterrupt` и общий `Exception` в блоке `__main__` с меткой `[CRITICAL]` — упрощает диагностику падений.

### Ошибки/устойчивость
- `startup()` обёрнут в try/except — при фатальной ошибке ре‑raise (чтобы контейнер рестартанул согласно политикам Docker). ✅
- Проверки конфигурации печатают информативные статусы (в т.ч. отключение интеграции с n8n, если URL пустой).

### Потенциальные узкие места/риски (заметки)
- **FSM: MemoryStorage** — состояние теряется при рестарте контейнера; для лид‑воронки ок, если шаги короткие. Если есть длинные анкеты — возможны потерянные сессии при деплое.
- **Таймеры:** `TimerService.active_timers` — in‑memory. После рестарта все таймеры исчезнут. Если это ремайндеры лидов — ожидаемое поведение, но важно осознанно.
- **Тест вебхука:** в DEBUG синхронный вызов перед стартом может задержать готовность контейнера при сетевых лагов. Убедиться, что внутри есть таймаут (заметка, т.к. реализация не показана).
- **Логи:** смешение `print`/`logging` усложняет унификацию; при желании проще перевести статусы на `logging` уровни (`INFO/WARNING/ERROR`).

### Сильные стороны
- Чистая точка входа, без бизнес‑логики.
- Ясные статусы загрузки/инициализации.
- Безопасная печать URL n8n (маскирование).
- Отдельные роутеры `user`/`admin`.

### Вопросы к контексту (для себя, не требуются ответы прямо сейчас)
- Используется ли где‑то webhook‑режим Telegram, или строго поллинг?
- Нужна ли устойчивость таймеров и FSM через рестарты (персистентность)?
- Есть ли rate‑limit/ антиспам‑middleware в роутерах (важно для прод)?

### Итог по run.py
- Входная точка выполнена аккуратно; явных проблем не обнаружено. Файл готов к «финальным штрихам» в части воронки и интеграции с n8n — это будет уже на уровне хэндлеров/сервисов, а не `run.py`.

## 3.1) Константы — `app/constants.py`
**Назначение:** единый центр конфигурационных констант для UX/валидации/воронки/таймеров/безопасности.

**Содержимое и применение:**
- **Rate limit:** `USER_REQUESTS_LIMIT=30` за `USER_REQUESTS_WINDOW=60s` — используется в `user.rate_limit`. Довольно щадящий лимит на пользователя; спам не пройдёт, но реактивные клики не будут резаться.
- **Таймеры:**
  - `DEFAULT_CALCULATED_TIMER_DELAY=60` (минуты) — передача в `TimerService.start_calculated_timer` (ожидание перед переводом в `calculated` лид).
  - `DELAYED_OFFER_DELAY=3` (секунды) — задержка для отложенного сообщения «оффера»; хороша для демо/теста. В проде тайминг обычно больше (заметка продуктовая).
- **Приоритеты лидов (`PRIORITY_SCORES`)**: числа для сортировки «горячих» — `consultation_request=100`, `hotlead_delayed=80`, `coldlead_delayed=10`, `coldlead=5`, `new=0`. Используются при выставлении статусов в `user.py` и для выборки в админке.
- **Валидация (`VALIDATION_LIMITS`)**: возраст 15–80, вес 30–200, рост 140–220 — применяются в валидации инпутов FSM.
- **Безопасность:** `MAX_TEXT_LENGTH=100` для `sanitize_text`; `DB_OPERATION_TIMEOUT=10s` для `safe_db_operation`.
- **Статусы воронки (`FUNNEL_STATUSES`)**: перечисление используемых статусов — `new`, `calculated`, `hotlead_consultation`, `hotlead_delayed`, `coldlead_delayed`, `coldlead`. Совместимы с фильтрами DAL (`LIKE '%hotlead%'`).
- **Приоритеты пользователя (`USER_PRIORITIES`)**: `nutrition|training|schedule` — соответствуют callback'ам и UI‑кнопкам.

**Заметки (без правок):**
- Названия статусов/приоритетов сведены в одну точку — снижает риск опечаток по коду.
- Если захотите ввести подстатусы «очень горячий» и т.п., можно расширить `PRIORITY_SCORES` и/или `FUNNEL_STATUSES` — админская выборка уже поддерживает `LIKE '%hotlead%'`.
- Порог рейт‑лимита подойдёт большинству сценариев; если ожидаете активные «листалки» пользователями, можно увеличивать окно/лимит — это уже продуктовая настройка.

## 4) Бизнес‑логика и сценарии бота
Источник: `app/user.py`

### Общая схема флоу
1. **/start** → `set_user()` (upsert) → `send_welcome_sequence()` (фото тренера → приветствие + `main_menu`).
2. **Меню** → `start_kbju_flow()`.
3. **КБЖУ‑анкета:**
   - `gender_*` → `waiting_age` → ввод возраста (валидация по `VALIDATION_LIMITS`).
   - `waiting_weight` → ввод веса (float, «,» → «.»).
   - `waiting_height` → ввод роста.
   - `activity_*` (min/low/medium/high) → маппинг в калькулятор (`low/moderate/high`).
   - `goal_*` (weight_loss / maintenance / weight_gain) → расчёт.
4. **Расчёт и воронка:** `calculate_and_save_kbju()` → запись результатов и статуса `calculated`, `priority_score=PRIORITY_SCORES['new']`, `calculated_at=utcnow`.
5. **Таймеры:** `start_funnel_timer()` (через `TimerService.start_calculated_timer`) + **отложенный оффер** `schedule_delayed_offer()`.
6. **Ответвления:**
   - `delayed_yes` → выбор приоритета → статус `hotlead_delayed` → оффер консультации + кнопка контакта.
   - `delayed_no` → статус `coldlead_delayed` → `WebhookService.send_cold_lead(...)` → советы по цели + CTA на канал.
   - `send_lead` → статус `hotlead_consultation` → `WebhookService.send_hot_lead(..., 'consultation_request')` → подтверждение.
   - `funnel_cold` (ручной) → статус `coldlead` → `WebhookService.send_cold_lead(...)` → совет + CTA.

### Рейт‑лимит и устойчивость
- **`rate_limit` декоратор:** in‑memory ведро на пользователя (`USER_REQUESTS_LIMIT`/`WINDOW`), «тихий» отказ без сообщения пользователю (выбор осознанный). При горизонтальном масштабировании лимит распределён не будет — это нормально для текущей архитектуры.
- **`error_handler` декоратор:**
  - Ловит `TelegramBadRequest` (в т.ч. «message is not modified»), `TelegramRetryAfter` (ждёт `retry_after`), и общий `Exception`.
  - В случае UI‑ошибок пробует отправить безопасное сообщение `errors.general_error` + `back_to_menu()`.
  - Работает и для `Message`, и для `CallbackQuery` (через проверку `args[0]`).

### Утилиты
- **`sanitize_text`** — `html.escape` + обрезка до `MAX_TEXT_LENGTH`. Применяется к `username/first_name` и текстовым инпутам анкеты.
- **`safe_db_operation`** — оборачивает вызовы DAL в `asyncio.wait_for` с `DB_OPERATION_TIMEOUT`, логирует таймауты и исключения.
- **`get_advice_by_goal`** — вытягивает тексты советов из словаря `texts` по ключу цели.
- **`_user_to_dict`** — строго приводит типы для вебхуков (int/float/str) — удобно для n8n.

### Калькулятор и тексты — `app/calculator.py`
**Формула:** Миффлин—Сан Жеор: `BMR = 10w + 6.25h − 5a + s`, где `s=+5` (муж) / `−161` (жен). Далее `calories_maintenance = BMR * activity_coef`, целевые калории = `maintenance * (1 + goal_adjust)`.

**Коэффициенты активности (в коде):**
- `low=1.2`, `moderate=1.375`, `high=1.55`, `very_high=1.725`.
  - В текущем UI кнопок `very_high` нет; есть `activity_min` → маппинг в `low` (см. `ACTIVITY_INPUT_MAP`).

**Цели:**
- `weight_loss=-15%`, `maintenance=0%`, `weight_gain=+10%`.

**БЖУ:**
- Белок `1.8 г/кг`, жиры `25%` калорий, углеводы — остаток. Итог округляется до `int`; сумма макро может слегка расходиться с калориями — допустимо.

**API:**
- `calculate_kbju(...)` возвращает `{'calories','proteins','fats','carbs','bmr'}` — `bmr` пока не используется в UI, но может пригодиться (например, в админке/вебхуках).
- `validate_user_data(...)` возвращает `(bool, message)` — **в текущем флоу не используется**, валидация выполнена в `user.py` через `VALIDATION_LIMITS`.
- `get_activity_description()/get_goal_description()` — берут подписи из JSON (`activity_descriptions.*`, `goal_descriptions.*`).

**Заметки (без правок):**
- **Дублирование правил:** диапазоны `15–80/30–200/140–220` зашиты и здесь (`validate_user_data`), и в `constants.VALIDATION_LIMITS`. Сейчас используется только `constants`; если когда‑то включите `validate_user_data`, следите, чтобы правила не разъехались.
- **Ключ `errors.gender_invalid`:** в `texts_data.json` такого ключа **нет** (есть `age_invalid/weight_invalid/height_invalid` и др.). Поскольку `validate_user_data` не вызывается — это не влияет. Просто заметка.
- **Совместимость активности:** `user.py` маппит `activity_medium → moderate` — совпадает с ключами калькулятора и текстов.
- **Стабильность:** модуль чисто математический и без побочных эффектов; быстро и надёжно для прод.

### Таймеры и отложенные сообщения
- **`TimerService`** — основная механика таймеров (отдельный модуль), отмена таймера происходит при старте анкеты и при явных развилках.
- **`schedule_delayed_offer`** → `asyncio.create_task(send_delayed_offer(...))`, внутри создаётся **новый** `Bot` на каждый запуск и закрывается после отправки — полностью изолировано от `Dispatcher`. На shutdown отменяются только таймеры `TimerService` (заметка: отложенные офферы не трекаются сервисом).

### Профиль
- `/profile` показывает карточку профиля, если есть `calories`. Подписи целей/активности — из словаря/хелпера. Дата расчёта в `ДД.ММ.ГГГГ`.

### Итог по модулю user
- Флоу структурирован и читабелен: декораторы отвечают за устойчивость, FSM — за этапы анкеты, тексты/клавиатуры — централизованы. Интеграции с n8n инкапсулированы в `WebhookService` (см. далее). Сильная сторона — отсутствие бизнес‑логики в точке входа и чёткое разделение ответственности.
- Флоу структурирован и читабелен: декораторы отвечают за устойчивость, FSM — за этапы анкеты, тексты/клавиатуры — централизованы. Интеграции с n8n инкапсулированы в `WebhookService` (см. далее). Сильная сторона — отсутствие бизнес‑логики в точке входа и чёткое разделение ответственности.

## 5) Конфигурация и секреты
Источник: `config.py`

### Что делает файл
- Загружает `.env` через `load_dotenv()` (по умолчанию **не** переопределяет уже существующие переменные окружения контейнера).
- Нормализует булевы значения функцией `_bool()` → `DEBUG`.
- Поддерживает алиас токена: `TOKEN` **или** `BOT_TOKEN` (в коде используется `TOKEN`).
- Задаёт дефолты для БД и интеграций:
  - `DB_URL`: `sqlite+aiosqlite:///db.sqlite3`
  - `N8N_WEBHOOK_URL`: пустая строка по умолчанию (интеграция выключена)
  - `CHANNEL_URL`: пустая строка (опциональная ссылка на канал)
- Если токен не задан, печатает предупреждение на импорт‑этапе.

### Заметки (без правок кода)
- **Загрузка .env в проде:** `load_dotenv()` удобен для локалки; в Docker обычно достаточно переменных окружения. По умолчанию `python-dotenv` не перезаписывает уже заданные значения — это безопасно. Важно понимать порядок источников: переменные из контейнера имеют приоритет над `.env`.
- **DB path:** дефолт `db.sqlite3` — относительный путь к рабочей директории процесса. Для Docker лучше убедиться, что рабочая директория стабильна и файл примонтирован томом (иначе данные исчезнут при пересборке контейнера). Это уже организационный момент compose.
- **Булев парсер:** `_bool()` корректно обрабатывает популярные варианты (`1/true/yes/y/on`, регистр игнорируется). Если переменная отсутствует, `str(None)` → `'None'` → `False`, что соответствует задумке.
- **Вывод предупреждения при импорте:** печать «BOT_TOKEN не установлен» на уровне импорта помогает в локалке, но в тестах/скриптах может шуметь. Это просто отметить.
- **Безопасность:** значения чувствительных переменных нигде не печатаются (кроме маскированного URL в `run.py`). Это хорошо.
- **Единая типизация конфигурации:** в проекте уже есть `pydantic 2.x`; при желании можно централизовать конфиг в `BaseSettings` (валидация типов/дефолтов/множественных источников). Это опционально, так как текущая простая схема работает.
- **CHANNEL_URL:** объявлен, но в `run.py` не используется (вероятно применяется в хэндлерах для CTA и проверки подписки).

### Чек‑лист окружения для прод (на уровне DevOps)
- `BOT_TOKEN`/`TOKEN`: установлен в секретах
- `DB_URL`: явный путь/том для сохранности
- `N8N_WEBHOOK_URL`: задан (если интеграция включена)
- `CHANNEL_URL`: задан (если есть проверки подписки/CTA)
- `DEBUG=false`

## 6) Данные и модель
Источник: `app/database/models.py`

### Подключение БД и сессии
- `engine = create_async_engine(DB_URL, echo=True)` — асинхронный движок. `echo=True` полезен в DEV, в проде сильно шумит логами (заметка).
- `async_session = async_sessionmaker(engine)` — фабрика сессий (по умолчанию `expire_on_commit=True`). Важно понимать жизненный цикл сессии в хэндлерах (scoped на апдейт одной команды/хэндлера).
- `async_main()` создаёт таблицы через `Base.metadata.create_all` при старте бота.

### Модель `User`
- Ключи и идентификаторы:
  - `id` — PK (Integer), автогенерация.
  - `tg_id` — `BigInteger`, `unique=True` (идемпотентная регистрация/апсерт по Telegram‑ID).
- Профиль и вводимые данные:
  - `username(50)`, `first_name(100)` — опциональные.
  - `gender(10)` — допустимые значения по комментарию: `male/female`.
  - `age(Integer)`, `weight(Float)`, `height(Integer)` — опциональные.
  - `activity(20)` — `low/moderate/high/very_high`.
  - `goal(20)` — `weight_loss/maintenance/weight_gain`.
- Результаты расчёта КБЖУ:
  - `calories`, `proteins`, `fats`, `carbs` — `Integer`, опциональные.
- Воронка лидов:
  - `funnel_status(String(20), default='new')` — `new/calculated/hotlead/coldlead`.
  - `priority(String(20))` — тематический приоритет: `nutrition/training/schedule`.
  - `priority_score(Integer, default=0)` — числовая сортировка.
- Метки времени:
  - `created_at`, `updated_at` (`DateTime`, `utcnow`),
  - `calculated_at` — время последнего расчёта (используется для таймеров/ретаргета).

### Наблюдения и риски (заметки)
- **Типы и валидация:** бизнес‑ограничения (минимумы/максимумы `age/weight/height`) не выражены в схеме — это ок, если они валидируются в хэндлерах до записи.
- **Единицы измерения:** `weight` как `Float` (кг), `height` как `Integer` (см) — последовательно. В КБЖУ поля выбраны `Integer` — значит округление до целого (осознанно).
- **Статусы/категории:** значения для `gender/activity/goal/funnel_status/priority` документированы комментами; технически можно было бы закрепить `Enum`/`CheckConstraint` (отмечаю как архитектурную заметку, без необходимости менять код).
- **Индексы:** кроме `unique(tg_id)` явных индексов нет. Для сортировки/фильтрации лидов пригодятся индексы на `funnel_status` и `(priority_score DESC)` (особенно если выборка в админке по «горячим» лид‑сигналам).
- **Даты:** `DateTime` с `datetime.utcnow` создаёт на клиенте «наивные» UTC‑времена; в SQLite они сохраняются как строки. Это ок, если везде используете UTC. Если нужна TZ‑осознанность — держать в уме на уровне представления.
- **Миграции:** создание схемы через `create_all` удобно на старте, но без Alembic обновления полей/индексов потребуют ручных шагов. Если схема стабилизируется — текущего подхода достаточно.
- **Echo SQL:** `echo=True` в проде может вывести PII в логи. Если логи отправляются во внешний сборщик — стоит помнить (заметка к настройке окружения).

### Типовые сценарии работы с моделью
- Идемпотентная регистрация по `tg_id` (find‑or‑create), обновление профиля, расчёт КБЖУ → запись `calculated_at`, установка `funnel_status` → `calculated` и присвоение `priority/priority_score`.
- Админ‑панель/команда: сортировка по `priority_score DESC`, фильтрация `funnel_status IN (...)` для фокуса на «горячих».

## 6.1) Слой доступа к данным (DAL) — `app/database/requests.py`

### Общая структура
- Паттерн «сессия на вызов» (`async with async_session()`) — чисто, без глобальных сессий; каждая операция атомарна.
- Возвраты: часть функций возвращают сущность (`get_user`, `update_user_data`, `update_user_status`), часть — `None` (`set_user`). Это норм, важно учитывать на уровне хэндлеров.

### Функции
- **`set_user(tg_id, username=None, first_name=None)`**
  - Поведение: upsert‑подобное — поиск по `tg_id`, создание при отсутствии, иначе обновление `username/first_name` и `updated_at`.
  - Плюсы: идемпотентность по `tg_id`, базовый `priority_score=0`, стартовый статус `new`.
  - Заметки: при конкурентных вызовах (редко, но возможно при одновременном старте) два процесса могут одновременно «не найти» пользователя и попытаться создать — защитит `unique(tg_id)`, но это будет IntegrityError на одной из транзакций (общее замечание про гонки).

- **`get_user(tg_id)`**
  - Простая выборка по `tg_id`. Возвращает `User | None`.

- **`update_user_data(tg_id, **kwargs)`**
  - Массовое обновление полей: для каждого ключа из `kwargs` проверяется `hasattr(user, key)` и выполняется `setattr`.
  - Плюсы: гибко, можно обновлять разные части профиля одной функцией.
  - Заметки: если `kwargs` формируется из внешнего ввода, нужна валидация/белый список на уровне хэндлеров (чтобы не перетирать системные поля вроде `id/tg_id/created_at`). Сейчас это вопрос дисциплины вызывающего кода, сам DAL пропускает всё существующее.

- **`update_user_status(tg_id, status, priority=None, first_name=None, priority_score=None)`**
  - Обновляет статус воронки, приоритет, имя и скор, плюс `updated_at`.
  - Заметки: допустимые значения `status/priority` стоит контролировать выше по стэку (валидация), здесь — свободная строка.

- **`get_calculated_users_for_timer()`**
  - Выбирает пользователей со статусом `calculated` и не‑`NULL` `calculated_at`.
  - Заметки: порядок не задан — если нужна очередность обработки, можно сортировать по `calculated_at` (старые сначала) — это заметка для бизнес‑логики, а не требование.

- **`get_hot_leads()`**
  - Фильтр `User.funnel_status.like('%hotlead%')` + сортировка по `priority_score DESC, updated_at DESC`.
  - Плюсы: вытягивает все подстатусы «горячих» (если они именуются с префиксом/суффиксом `hotlead`).
  - Заметки: `LIKE` хуже используют индексы, чем `=`; если статусы дискретны (например, `hotlead` и `very_hotlead`), лучше фильтровать перечислением (`IN`) — это архитектурная пометка к будущему росту данных.

### Перфоманс/надёжность
- Для будущих больших выборок админских списков пригодятся индексы на `funnel_status` и `priority_score`.
- Сессии коммитят изменения, явного `rollback` при исключении нет — контекст менеджер сам приведёт сессию в порядок, это стандартный паттерн SQLAlchemy 2.0.
- Дата/время через `datetime.utcnow()` остаются на стороне приложения — это ок для SQLite; если будет миграция на PostgreSQL, всё также будет ок (хотя можно будет перенести часть на `server_default` при желании).

## 7) Интеграции
*(пока отмечены на уровне run.py / config; детальный разбор появится после просмотра соответствующих модулей n8n/webhook и калькулятора)*

### 7.1) Админ‑панель — `app/admin.py`
[см. выше]

### 7.2) Вебхуки n8n и таймеры — `app/webhook.py`

**Состав:** `WebhookService` (отправка), `send_with_retry` (ретраи), `validate_payload` (валидация), `WebhookMetrics` (метрики), `TimerService` (in‑memory таймеры), `test_webhook_connection`.

**Логика отправки:**
- Если `N8N_WEBHOOK_URL` пуст — в DEV возвращает `True` и пишет в лог (не мешает локалке). В проде URL должен быть задан.
- `validate_payload(payload, lead_type)`: обязательные поля `user_id/lead_type/timestamp`; `lead_type ∈ {hot,cold,calculated}`. Доп. проверка: hot‑лиды желательно иметь `priority` (warning, не ошибка).
- `send_with_retry(payload, max_attempts)`:
  - Создаёт `aiohttp.ClientSession` на каждый вызов; таймаут увеличивается 5→7→9… сек по попыткам; экспоненциальный backoff 1/2/4 сек.
  - Успех только при HTTP **200** (прочие 2xx считаются ошибкой) → метрики успеха/ошибок.
  - 4xx ошибки не ретраятся (правильно); таймаут/5xx — с ретраями до лимита.
  - Все исключения логируются; финальный результат — `True/False`.

**WebhookService API:**
- `send_hot_lead(user_data, priority)` → `lead_type='hot'`, `max_attempts=5`.
- `send_cold_lead(user_data)` → `lead_type='cold'`, `max_attempts=2`.
- `send_calculated_lead(user_data, calculated_at?)` → `lead_type='calculated'`, `max_attempts=3`.
- `get_webhook_health()/reset_metrics()` — оперативные метрики процесса (не межпроцессные).

**TimerService:**
- `active_timers: dict[user_id, Task]` — in‑memory реестр активных таймеров.
- `start_calculated_timer(user_id, delay_minutes)` запускает таск: `sleep(delay)` → `get_user(user_id)` → если `funnel_status == 'calculated'` → `WebhookService.send_calculated_lead(...)`. В конце — удаляет себя из реестра. Предыдущий таймер для user_id отменяется.
- `cancel_timer(user_id)` — отмена существующего таймера. В `run.py` при shutdown отменяются все таймеры.
- Комментарии верно отмечают, что для прод‑устойчивости хранение стоит вынести в Redis (персистентность между рестартами).

**Метрики:**
- Класс‑счётчики (успех/ошибка), success_rate, время/текст последней ошибки, статус `healthy/degraded` при пороге 0.8. Процесс‑локальные; не агрегируются между репликами.

**`test_webhook_connection()`:**
- Формирует `test_data` с `lead_type='test'` и вызывает `send_with_retry(..., max_attempts=1)` → ввиду валидации `lead_type ∉ {hot,cold,calculated}` тест **всегда** будет `failed` без фактического запроса (ошибка валидации). Это объясняет предупреждение при старте в DEBUG (`[WARN] Webhook connection issues`).
- Возвращает отчёт со временем ответа и текущими метриками.

**Замечания/риски (без правок кода):**
- **Коды успеха:** сейчас учитывается только 200. Многие вебхуки могут отвечать 201/202/204; если n8n настроен на 200 — ок, иначе тесты будут считать это ошибкой.
- **Сессии aiohttp:** создание новой `ClientSession` на каждый вызов — ок при низком RPS; для бурстов выгоднее переиспользовать одну сессию на процесс (не обязательно менять).
- **Безопасность:** URL вебхука один и без подписи; если он публичен, разумно иметь секреты/подпись (например, HMAC в заголовке) и проверку на стороне n8n. Это организационная мера.
- **Метрики:** процесс‑локальные; в многоконтейнерной схеме «здоровье» будет частичным. Если понадобится сводное — экспортировать метрики наружу (Prometheus/лог‑скрейпинг).
- **Логи:** часть путей использует `print` (TimerService), часть — `logger`. Для единства наблюдаемости можно привести к `logger` (заметка).
- **Таймеры:** отложенные офферы из `user.schedule_delayed_offer()` не учтены в `TimerService` и не отменяются на shutdown — ожидаемо, но важно помнить при рестартах.

**Сильные стороны:**
- Чёткое разделение: валидация → ретраи → сервис высокого уровня.
- Кастомные метрики «из коробки».
- Удобные хелперы `send_hot/cold/calculated` с нужными retry‑профилями.

## 8) Обработка ошибок и логирование
- Единый `error_handler` декоратор в `user.py` для Telegram‑ошибок, сетевых ретраев и общего fallback‑сообщения.
- Логи: часть через `logging` (user/webhook), часть через `print` (run.py/webhook timers). Для прод‑наблюдаемости можно унифицировать уровни/формат (заметка).
- Метрики вебхуков: `WebhookMetrics` (успехи/ошибки, success_rate, last_error) — процесс‑локально.

## 8.1) Middleware — `CounterMiddleware`
**Файл:** (вероятно `app/middlewares/counter.py`)

**Что делает:**
- Наследуется от `BaseMiddleware`; ведёт простой счётчик обработанных **сообщений** в поле `self.counter`.
- На каждом вызове увеличивает счётчик и кладёт значение в `data['counter']`, чтобы хэндлеры могли его читать.

**Контекст и ограничения:**
- Счётчик **глобальный на процесс** и сбрасывается при рестарте контейнера.
- Подходит для отладки/демо‑метрик; не замещает бизнес‑статистику.
- Типизация и сигнатура заточены под `Message`; для `CallbackQuery` это middleware не сработает (если не оборачивать и их тип событий).
- В проекте **пока не подключён** (в `run.py` не регистрируется). Если когда‑то будет подключён, накладные расходы пренебрежимы.
- Инкремент выполняется без `await`, поэтому в рамках одного event loop операция атомарна (переключение задач происходит на `await`), гонки не ожидаются.

**Где может пригодиться:**
- Быстро понять, сколько сообщений прошло через процесс, и передать это число в хэндлеры для отладки.

## 9) Деплой и окружения

### Dockerfile (многостадийная сборка)
- **База:** `python:3.12-slim-bookworm` для `builder` и `runtime` — современно и компактно.
- **Builder‑стадия:** apt‑набор `gcc, libpq-dev` (для возможных C‑билдов и Postgres‑клиента), установка зависимостей в `venv` по `requirements.txt`.
- **Runtime‑стадия:** только `libpq5` и `ca-certificates` + копирование готового `/opt/venv` и кода в `/app`.
- **ENV:** `PYTHONPATH=/app`, `PATH=/opt/venv/bin:$PATH` — запуск идёт через виртуалку.
- **Запуск:** `CMD ["python", "run.py"]` — бот на поллинге.
- **Права:** создаётся `appuser` (UID 1001), `chown -R /app`, запуск non‑root — 👍 по безопасности.
- **Fallback‑config:** при отсутствии `config.py` генерируется минимальный (без `dotenv`). В репозитории у нас есть полноценный `config.py` — fallback не используется, но полезен для шаблонов.

### docker-compose.yml
**Сервисы:**
- `bot`: билд из `Dockerfile`, `restart: unless-stopped`, `.env`, тома `./db.sqlite3:/app/db.sqlite3`, `./logs:/app/logs`, зависит от `postgres` по `service_healthy`, healthcheck всегда `0`.
- `postgres`: `postgres:15-alpine`, переменные `POSTGRES_*`, том `postgres_data`, healthcheck `pg_isready`.

**Заметки (без правок):**
- **SQLite vs Postgres:** в коде по умолчанию `DB_URL=sqlite+aiosqlite:///db.sqlite3` и в `requirements.txt` **нет** драйвера PostgreSQL (`asyncpg`/`psycopg`). При текущем конфиге бот работает на SQLite, а контейнер `postgres` фактически не используется. Если планируете перейти на Postgres, нужны: (1) установить `asyncpg`, (2) задать `DB_URL=postgresql+asyncpg://kbju_user:...@postgres:5432/kbju_bot` в `.env`, (3) убедиться, что миграции/создание таблиц работают с Postgres. Если остаётесь на SQLite — `postgres` сервис и `depends_on` можно убрать (организационная чистка).
- **Тома:** монтируется `db.sqlite3` — обеспечивает персистентность. Монтируется `./logs`, но приложение пишет в stdout (через `logging.basicConfig`/`print`) и **не** пишет в `/app/logs`; том может быть неиспользуемым.
- **Healthcheck бота:** `python -c 'import sys; sys.exit(0)'` всегда возвращает `0` → healthcheck формальный. Если он нужен по делу, можно проверять, например, доступность БД/Telegram API (заметка продуктового уровня).
- **depends_on:** условие `service_healthy` годится при Postgres‑БД; при SQLite зависимость не нужна. Если переключитесь на Postgres, это пригодится.
- **Секреты:** `POSTGRES_PASSWORD` берётся из `.env`. Убедиться, что `.env` не попадает в образ (через `.dockerignore`) и хранится в секрете CI.
- **Сеть:** отдельная bridge‑сеть `bot_network`; обращения к БД по имени `postgres` будут работать внутри сети.
- **Часовой пояс/локаль:** не задаётся — в коде используется UTC; для логов это ок.

### CI/CD — GitHub Actions (`.github/workflows/deploy.yml`)
**Триггеры:** push в `main` и ручной запуск (`workflow_dispatch`).

**Шаги:**
1) Checkout репозитория. 2) SSH на сервер (`appleboy/ssh-action`). 3) На сервере:
   - Жёсткая синхронизация кода: `git fetch/reset --hard origin/main` в `$SERVER_PATH` (по умолчанию `/root/bots/kbju_bot`). Предполагается, что репозиторий уже инициализирован на сервере и привязан `origin`.
   - Остановка контейнеров: `docker compose stop` (будет **короткий даунтайм**).
   - Агрессивная очистка Docker: prune images/containers/networks/build‑cache (тома **не** трогаются).
   - Сборка и запуск: `docker compose pull postgres || true`, `docker compose build bot`, `docker compose up -d`.
   - Health‑loop: 10 попыток проверить `Up.*healthy` в `docker compose ps`.
   - Вывод хвоста логов и финальной статистики диска.

**Наблюдения/заметки:**
- **Healthcheck:** в compose бот всегда «healthy», так как тест `sys.exit(0)` → цикл почти всегда пройдёт. Это ок, если цель — дождаться старта контейнера, а не проверять реальную готовность.
- **Downtime:** используется `stop` → `up -d` — присутствует пауза. Если нужна бездаунтаймность, понадобятся другие стратегии (rolling/blue‑green через версии образов) — это уже продуктовый выбор.
- **Docker cache:** перед сборкой выполняется `builder prune -af` → кэша почти не будет, билд всегда «с нуля». Это экономит диск, но удлиняет сборку.
- **Postgres:** выполняется `compose pull postgres`, хотя по факту используется SQLite. Шаг безопасен, но лишний при SQLite‑режиме.
- **Секреты/переменные:** SSH‑доступ через секреты `SERVER_HOST/SERVER_USER/SSH_PRIVATE_KEY`. `.env` должен лежать на сервере в `$SERVER_PATH` (compose читает `env_file: .env`).
- **SERVER_PATH:** берётся из переменной окружения с дефолтом; важно, чтобы на сервере существовал этот путь и в нём был git‑репозиторий.
- **Конкурентность:** несколько пушей подряд могут запустить параллельные деплои. Если важно исключить гонки — можно использовать `concurrency: group: deploy-main` в workflow (заметка организационная).
- **Требования на сервере:** установлен Docker Compose v2 (команда `docker compose`), git, права на каталог, корректно настроенный known_hosts (ssh‑action сам управляет).

## 10) Безопасность
- Запуск под non‑root пользователем — плюс.
- Секреты не логгируются (URL n8n маскируется). Важно держать `.env` вне образа (через `.dockerignore`).
- Поведение при отсутствии `TOKEN` — ранний warning на импорт `config.py` (локалка) и crash при запуске — ожидаемо.

## 11) UX и текстовая упаковка
- Запуск под non‑root пользователем — плюс.
- Секреты не логгируются (URL n8n маскируется). Важно держать `.env` вне образа (через `.dockerignore`).
- Поведение при отсутствии `TOKEN` — ранний warning на импорт `config.py` (локалка) и crash при запуске — ожидаемо.

## 11) UX и текстовая упаковка
- защита команд /admin, rate‑limits, анти‑спам
- Webhook‑секреты, сигнатуры
- Очистка PII логов

## 11) UX и текстовая упаковка
- Единый источник текстов и кнопок — `app/texts_data.json`, доступ через адаптер `app/texts.py`.
- Тексты используют HTML‑разметку (бот отправляет с `parse_mode=HTML`).
- Плейсхолдеры форматируются через `.format(**kwargs)` — значения, приходящие от пользователя, должны быть экранированы до шаблона (в коде это делается через `sanitize_text`).

### 11.1) Модуль текстов — `app/texts.py`
**Назначение:** тонкий адаптер между кодом и JSON‑хранилищем текстов.

**Как устроено:**
- Глобальный кэш `TEXTS: Dict[str, Any]` + кэш времени изменения файла `_LAST_MTIME`.
- `load_texts(force=False)`: лениво перечитывает `app/texts_data.json`, только если поменялся `mtime` (быстро и безопасно). При ошибках — печатает предупреждение.
- `save_texts()`: сохраняет текущие `TEXTS` обратно в JSON (используется админкой). После записи обновляет `_LAST_MTIME`.
- `_resolve_key('a.b.c')`: поддержка вложенных ключей.
- `_deep_update(dst, src)`: глубокое объединение словарей (здесь используется после `TEXTS.clear()`, по сути — безопасная загрузка структуры).
- Путь до файла определяется относительно модуля (`os.path.dirname(__file__)`).

**Публичный API:**
- `get_text(key, **kwargs)`: возвращает строку/узел; если узел — dict, берёт `['text']`; подставляет плейсхолдеры через `.format(**kwargs)`.
- `get_button_text(key)`: возвращает подпись из блока `buttons`.

### 11.2) Структура `app/texts_data.json` (разбор)
- `coach_photo_url` — URL для приветственного фото (используется в `send_welcome_sequence`).
- Блоки с полями `{ "title", "text" }`: `welcome`, `main_menu`, `delayed_offer`, `consultation_offer`, `kbju_result`, `profile.template`, `kbju_start`, `hot_lead_success`, `hot_lead_working` (см. ниже про использование).
- `advice.{goal}` — тексты советов для: `weight_loss`, `maintenance`, `weight_gain`.
- `priority_descriptions.{nutrition|training|schedule}` — описания направлений (сейчас **не используются** напрямую; UI берёт подписи из `buttons.priority_*`).
- `goal_descriptions.{weight_loss|maintenance|weight_gain}` — человекочитаемые цели (используются при расчёте и выводе результата).
- `activity_descriptions.{low|moderate|high|very_high}` — словарь для отображения; в текущем UI есть кнопки `activity_min|low|medium|high` (см. соответствие ниже).
- `questions.*` — вопросы анкеты. Использование плейсхолдеров:
  - `questions.weight` — `{age}` ✔︎ (передаётся в `process_age`)
  - `questions.activity` — `{height}` ✔︎ (в `process_height`)
  - `questions.goal` — `{activity_text}` ✔︎ (в `process_activity`)
- `errors.*` — стандартные сообщения об ошибках.
- `admin.*` — тексты админки (`welcome`, `no_hot_leads`, `counter`, `lead_card`).
- `buttons.*` — подписи кнопок; используются в билдерах клавиатур.

### 11.3) Карта соответствий «кнопка → калькулятор/текст»
- **Активность (callback):** `activity_min|low|medium|high` → в коде маппятся в калькулятор `{'min': 'low', 'low': 'low', 'medium': 'moderate', 'high': 'high'}`.
  - В `activity_descriptions` используется ключ `moderate` (совместимо с маппингом). Ключ `very_high` присутствует в словаре, но сейчас **нет кнопки** `activity_very_high` — запас на будущее.
- **Цели:** `goal_weight_loss|goal_maintenance|goal_weight_gain` → ключи `goal_descriptions.*` и `advice.*`.
- **Приоритеты:** кнопки `priority_{nutrition|training|schedule}` используются и в админке (через `get_button_text`).
- **Оффер (delayed):** кнопки `delayed_yes`/`delayed_no` используются в хэндлерах; присутствуют в JSON. Старые ключи `ready_to_work`/`want_advice` остались в JSON — вероятно из ранней версии, сейчас **не используются**.

### 11.4) Неиспользуемые/избыточные ключи (на текущей версии кода)
- `questions.gender` — старт диалога берётся из `kbju_start`; сам текст `questions.gender` не вызывается напрямую (может пригодиться для альтернативного флоу).
- `hot_lead_working` — в текущем `user.py` не используется (после выбора приоритета показывается `consultation_offer`).
- `activity_descriptions.very_high` — нет соответствующей кнопки.
- `buttons.ready_to_work`, `buttons.want_advice` — не используются; заменены на `delayed_yes/no`.

### 11.5) Плейсхолдеры и форматирование (проверка соответствия)
- `hot_lead_success`: `{user_id}`, `{username}` — в коде передаются `user_id` и `username` (без `@`), а в шаблоне уже стоит `@{username}` → итог корректный.
- `kbju_result`: `{goal_text}`, `{calories|proteins|fats|carbs}` — формируются из расчёта ✔︎.
- `profile.template`: все плейсхолдеры заполняются в `show_profile` ✔︎.
- `cold_lead_advice`: `{advice_text}`, `{channel_url}` — подставляются в `process_delayed_no`/`process_cold_lead` ✔︎.

### 11.6) Язык/стиль и UX‑заметки (без правок текста)
- Сообщения уложены в лимиты Telegram (визуально < 4 096 символов). Разметка `<b>/<i>/<code>` используется ровно, без вложенных тегов.
- Первые строки в ключевых сообщениях (`welcome`, `delayed_offer`, `consultation_offer`) чётко формулируют ценность и CTA — это хорошо для конверсии.
- Для кликабельности канала достаточно `@username`; если нужен прямой URL, можно хранить `https://t.me/...` в `CHANNEL_URL` (в коде это поле уже есть).
- Фото приветствия подтягивается по `coach_photo_url`; важно, чтобы ссылка была доступна из контейнера (хостинг i.ibb.co обычно стабильный).

### 11.7) Идеи для A/B (на будущее, без правок)
- Варианты `delayed_offer` с разными триггерами (рациональность vs. эмоции) и разный тайминг `DELAYED_OFFER_DELAY`.
- Два варианта `consultation_offer`: короткий чек‑лист «что получишь» vs. более эмоциональный рассказ.
- Добавить `activity_very_high` в UI, если появится необходимость, либо удалить описание из словаря, чтобы держать JSON «чистым».

### 11.8) Клавиатуры — `app/keyboards.py`
**Состав клавиатур:**
- `main_menu()` — «Рассчитать КБЖУ», «Мой профиль».
- `gender_keyboard()` — «Мужской/Женский».
- `activity_keyboard()` — `min/low/medium/high` (синхронизировано с `user.py` и маппингом в калькулятор).
- `goal_keyboard()` — `weight_loss/maintenance/weight_gain`.
- `funnel_keyboard()` — (старый вариант) `ready_to_work/want_advice`.
- `priority_keyboard()` — `priority_{nutrition|training|schedule}`.
- `profile_keyboard()` — «Пересчитать КБЖУ», «Главное меню».
- `admin_menu()` — задел под админ‑панель: `admin_stats/admin_broadcast/admin_users`.
- `delayed_offer_keyboard()` — `delayed_yes/delayed_no`.
- `consultation_contact_keyboard()` — «Оставить заявку», «Главное меню».
- `back_to_menu()` — «Главное меню».

**Связь с JSON‑ключами:** все тексты подтягиваются через `get_button_text(..)`.
- В `texts_data.json` **нет** ключей `admin_stats/admin_broadcast/admin_users` ⇒ `admin_menu()` сейчас вернёт заглушки вида «[Кнопка не найдена: …]`. При этом `admin_menu()` в коде не используется — это просто задел.
- `funnel_keyboard()` использует `ready_to_work/want_advice` — эти ключи в JSON есть, но сама клавиатура **не используется** (текущий сценарий — через `delayed_offer_keyboard`).
- Остальные клавиатуры соответствуют имеющимся ключам.

**Заметки (без правок):**
- Нейминг `callback_data` краткий и однозначный, вписывается в лимиты Telegram.
- Для UX уместно держать длину подписей кнопок короткой (сейчас ок); длинные подписи переносятся Telegram не всегда красиво.
- Синхронизация «activity» между кнопками (`min/low/medium/high`) и маппингом в `user.py` соблюдена.

## 12) Роадмап улучшений (заметки после run.py)
- **Наблюдаемость:** при желании — унифицировать логи на `logging` (уровни + формат), добавить метку версии билда (env `APP_VERSION`), логировать конфигурацию окружения без секретов.
- **Готовность контейнера:** если есть `HEALTHCHECK` в Docker, можно добавить лёгкий internal ping в старте (или отложенный self‑check) — чисто как улучшение диагностики.
- **Состояние:** если воронка многошаговая и длинная — рассмотреть Redis‑хранилище для FSM/таймеров (только если реально потребуется).

## 13) Открытые вопросы (заметки после run.py)
- **Наблюдаемость:** при желании — унифицировать логи на `logging` (уровни + формат), добавить метку версии билда (env `APP_VERSION`), логировать конфигурацию окружения без секретов.
- **Готовность контейнера:** если есть `HEALTHCHECK` в Docker, можно добавить лёгкий internal ping в старте (или отложенный self‑check) — чисто как улучшение диагностики.
- **Состояние:** если воронка многошаговая и длинная — рассмотреть Redis‑хранилище для FSM/таймеров (только если реально потребуется).

## 13) Открытые вопросы (заметки после run.py)
- **Наблюдаемость:** при желании — унифицировать логи на `logging` (уровни + формат), добавить метку версии билда (env `APP_VERSION`), логировать конфигурацию окружения без секретов.
- **Готовность контейнера:** если есть `HEALTHCHECK` в Docker, можно добавить лёгкий internal ping в старте (или отложенный self‑check) — чисто как улучшение диагностики.
- **Состояние:** если воронка многошаговая и длинная — рассмотреть Redis‑хранилище для FSM/таймеров (только если реально потребуется).

## 13) Открытые вопросы (заметки после run.py)
- **Наблюдаемость:** при желании — унифицировать логи на `logging` (уровни + формат), добавить метку версии билда (env `APP_VERSION`), логировать конфигурацию окружения без секретов.
- **Готовность контейнера:** если есть `HEALTHCHECK` в Docker, можно добавить лёгкий internal ping в старте (или отложенный self‑check) — чисто как улучшение диагностики.
- **Состояние:** если воронка многошаговая и длинная — рассмотреть Redis‑хранилище для FSM/таймеров (только если реально потребуется).

## 13) Открытые вопросы (будет дополняться)
- …

---

**Жду код: начнём с `run.py`.** После разбора каждый раздел выше заполню и дам точечные правки/рекомендации.

