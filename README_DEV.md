# Руководство разработчика

Документ описывает устройство Fitness Bot и перечисляет шаги для локальной разработки и развёртывания. Перед началом убедитесь, что прочитали пользовательский `README.md` — здесь рассматриваются только технические детали.

## 1. Архитектура проекта

```
app/
  ├─ user/               # Пользовательские хэндлеры (разделены по доменам)
  │   ├─ general.py      # /start, меню, профиль
  │   ├─ kbju.py         # опрос, расчёт КБЖУ, воронка
  │   ├─ leads.py        # админские списки лидов внутри бота
  │   ├─ contact.py      # ответы лидов на запрос обратной связи
  │   ├─ lifecycle.py    # события my_chat_member (отписки)
  │   └─ shared.py       # общие декораторы и утилиты
  ├─ admin.py            # инструменты для работы с лидами в ЛС
  ├─ calculator.py       # формула расчёта КБЖУ
  ├─ database/           # модели и DAO на SQLAlchemy 2.x
  ├─ features/           # модульные фичи (гейт по подписке и др.)
  ├─ drip_followups.py   # фоновая рассылка по неактивным пользователям
  ├─ webhook.py          # интеграции с n8n + таймеры напоминаний
  └─ texts.py            # загрузка/сохранение `texts_data.json`
utils/
  ├─ notifications.py    # конструкторы уведомлений для админа
  └─ smoke_polling.py    # вспомогательный скрипт для проверки polling
```

Главная точка входа — `run.py`. После старта создаётся экземпляр `Dispatcher`, к которому подключаются `app.user.user` и `app.admin.admin`.

## 2. Подготовка окружения

1. Установите Python 3.12.
2. Создайте виртуальное окружение и установите зависимости:
   ```bash
   python3 -m venv .venv
   source .venv/bin/activate
   pip install --upgrade pip
   pip install -r requirements.txt
   ```
3. Скопируйте `.env.example` (если есть) или создайте `.env` вручную. Минимальный набор переменных:
   ```env
   TELEGRAM_BOT_TOKEN=<токен бота>
   ADMIN_CHAT_ID=<ваш telegram id>
   DB_URL=sqlite+aiosqlite:///data/db.sqlite3
   ```
4. Для интеграций добавьте опциональные переменные:
   - `N8N_WEBHOOK_URL`, `N8N_WEBHOOK_SECRET` — отправка payload'ов в n8n.
   - `ENABLE_DRIP_FOLLOWUPS`, `DRIP_*` — фоновые догоняющие сообщения.
   - `ENABLE_SUBSCRIPTION_GATE`, `CHANNEL_ID_OR_USERNAME`, `CHANNEL_URL` — проверка подписки.

## 3. Локальный запуск

```bash
python run.py                 # старт бота (polling)
python start_admin_panel.py   # запуск админ-панели Flask (порт 8080)
```

Для проверки качества кода выполняйте компиляцию модулей (ловит синтаксические ошибки):

```bash
python -m compileall app utils
```

## 4. Работа с базой данных

- Конфигурация СУБД задаётся через `DB_URL` (по умолчанию SQLite).
- Модель `app/database/models.py` описывает таблицу `users`. При старте вызывается `async_main()`, создающая схему и проверяющая наличие дополнительных колонок.
- Все операции с БД вынесены в `app/database/requests.py`. Методы возвращают ORM-объекты или базовые типы и всегда вызываются через вспомогательную функцию `safe_db_operation()` (таймаут + логирование).

## 5. Потоки и таймеры

- `TimerService` (`app/webhook.py`) управляет двумя типами таймеров:
  - `start_calculated_timer` — бездействует до следующего шага воронки, можно использовать как hook для внешнего сервиса.
  - `start_stalled_timer` — напоминание о незавершённом опросе (включается переменной `ENABLE_STALLED_REMINDER`).
- `DripFollowupService` — фоновые «догоняющие» сообщения. Включите `ENABLE_DRIP_FOLLOWUPS=true` и задайте интервалы `DRIP_*`, чтобы активировать воркер.

## 6. Пользовательский флоу

1. `app/user/general.py` — старт, главное меню, профиль.
2. `app/user/kbju.py` — пошаговый опрос и расчёт. Все шаги валидируются, статусы и приоритеты обновляются в таблице `users`.
3. После расчёта планируется отправка отложенного предложения (`schedule_delayed_offer`), а данные отправляются в n8n (если включено).
4. Пользователь выбирает «горячий» или «холодный» путь, затем может оставить заявку или получить советы. Все переходы логируются и обновляют `funnel_status`.
5. Ответы на запрос «связаться» обрабатываются в `app/user/contact.py` и автоматически пересылаются админу.

## 7. Работа с контентом

- Все тексты, кнопки и media-id лежат в `app/texts_data.json`. Модуль `app/texts.py` обеспечивает ленивую загрузку и сохранение.
- Для добавления новых сообщений: создайте ключ в JSON, затем вызовите `get_text("path.to.key")` или `get_button_text("button_key")` в коде.
- Админ-панель (`start_admin_panel.py`) работает с тем же JSON и позволяет редактировать его через веб-интерфейс.

## 8. Логи и наблюдаемость

- Логирование настраивается в `run.py` (формат и уровень в зависимости от `DEBUG`).
- Дополнительные логи есть в сервисах (`DripFollowupService`, `TimerService`, обработчики хэндлеров). При необходимости добавьте `logger.debug` в соответствующий модуль.

## 9. Чек-лист перед релизом

1. `python -m compileall app utils`
2. Проверка `.env` на наличие обязательных переменных (`TELEGRAM_BOT_TOKEN`, `ADMIN_CHAT_ID`).
3. Прогон флоу в тестовом чате: расчёт КБЖУ → заявка → ответы админа.
4. Проверка интеграций (webhook / drip) при включённых флагах.

Следуя этим шагам, можно уверенно развивать бота, добавлять новые сценарии и интеграции без риска сломать основную логику.
